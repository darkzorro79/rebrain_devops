# rebrain_devops
##dz1
Ваша задача — полностью развернуть все компоненты нашего TODO-приложения:

    Установите базу данных postgresql и создайте пользователя для доступа приложения back.
    Запустите приложение back на порту 8080.
    Соберите frontend-приложение с помощью npm run build.
    Установите зависимости и запустите cleaner.py воркера.
    Установите и настройте nginx таким образом, чтобы запросы к /api отправлялись на приложение back, а при запросах на / отображалось front-приложение.

Проверка будет создавать и удалять задачи через api, а также проверять, что frontend-приложение отдаётся при запросах на /.

##dz2
Ваша задача — настроить автоматический деплой TODO приложения в gitlab.

Доступ в Gitlab вы можете получить в личном кабинете, в разделе Настройки практикума.

При входе в Gitlab у вас не будет создано ни одного проекта — это нормально. Вам необходимо сделать форк (скопировать) репозитории для каждого из приложений в свой namespace. Для этого:

    Откройте проект https://rbr-devops-workshop.gitlab.yandexcloud.net/rbr-todo/back, справа сверху нажмите Fork. В следующем меню выберите свой namespace (он будет один возможной) и тип проекта Private. Всё! Теперь вы можете добавлять изменения в свой проект.
    По аналогии сделайте так для проектов front и worker.

Что нужно сделать:

    Настроить на сервере вход пользователей по ключу (back, front, worker).
    Добавить разрешения в sudoers-файл для пользователей back и worker, чтобы они могли перезапускать сервис через systemctl.
    Добавить переменные SSH_PRIVATE_KEY и APP_HOST для каждого из проектов.
    Добавить файл .gitlab-ci.yml для каждого из проектов (front, back, worker), который будет содержать как минимум стадии сборки и деплоймента (для воркера только стадию деплоя). Стадии должны называться build и deploy.
    Проверить, что все стадии проходят и приложение успешно обновляется на сервере.
    На сервере склонировать ваши репозитории с файлом .gitlab-ci.yml в директорию /opt/repos/:

    /opt/repos/back — для back приложения;
    /opt/repos/front — для front приложения;
    /opt/repos/worker — для worker приложения. В данных директориях будет проверяться, что файл .gitlab-ci.yml содержит необходимые стадии. 
dz2/ansible/group_vars/all/vault.yml - добавьте токен доступа до вашего аккаунта gitlab (не конкретный репозиторий, а именно пользовательский (общий))

##dz3
Ваша задача — развернуть приложение в docker-контейнерах: postgres, worker, front, back. Единственный компонент, который остаётся вне контейнера — nginx. Опционально необходимо настроить CI/CD для обновления запущенных контейнеров на сервере.

Что нужно сделать:

    Написать Dockerfile для front, back и worker приложения.
    Создать отдельную сеть в docker — app.
    Запустить в контейнере базу данных postgres, в выделенной сети app.
    Запустить в сети app контейнеры для front, back, worker приложений.
    Настроить nginx на хост системе, чтобы он проксировал запросы на контейнер front и back.

В рамках проверки будут проверяться запущенные контейнеры и доступность приложения (api и front).

##dz4
Ваша задача — развернуть кластер docker swarm на трех узлах и запустить todo-приложение с образами, которые были собраны в предыдущем уроке и находятся в Gitlab.

Что нужно сделать:

    Настроить кластер swarm их трех узлов. Можно использовать любую комбинацию из manager и worker узлов. Можете сделать 1 manager ноду и 2 воркера, можете 3 manager узла. Но первая машина (vm-1) должна быть manager'ом в любом случае.
    Создать отдельную сеть с драйвером overlay в docker swarm - app.
    Создать stack postgres в swarm кластере, который запустит контейнер с базой postgres, в выделенной сети app.
    Создать stack nginx в swarm кластере, который запустит nginx, в выделенной сети app, который будет проксировать запросы на сервисы back и front.
    Создать стеки для приложений — back, front, worker, назвать их аналогично сервисам — back, front и worker, и запустить их в кластере swarm в сети app.

В рамках проверки будут проверяться запущенные сервисы и стеки в swarm кластере, а так же доступность приложения (api и front).

